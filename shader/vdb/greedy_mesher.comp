#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../vdb/common.glsl"

layout (
	local_size_x = 1,
	local_size_y = 1,
	local_size_z = 1
) in;

layout (binding = 0, std430) readonly buffer chunk_mask_buffer_t {
	chunk_mask_t chunk_mask[];
} chunk_mask_buffer;
layout (binding = 1, std430) writeonly buffer chunk_vertex_buffer_t {
	chunk_vertex_t chunk_vertex[];
} chunk_vertex_buffer;
layout (binding = 2, std430) writeonly buffer chunk_index_buffer_t {
	uint chunk_index[];
} chunk_index_buffer;
layout (binding = 3, std430) buffer chunk_info_buffer_t {
	chunk_info_t chunk_info[];
} chunk_info_buffer;

layout (push_constant) uniform push_constant_t {
	ivec3 chunk_position;
	uint chunk_index;
} pc;

void emit_quad(ivec3 p0, ivec3 p1, ivec3 p2, ivec3 p3, uint face) {
	uint v = atomicAdd(chunk_info_buffer.chunk_info[pc.chunk_index].vertex_count, 4);
	uint i = atomicAdd(chunk_info_buffer.chunk_info[pc.chunk_index].index_count, 6);

	vec3 normal = vec3(0);

	switch (face) {
		case FACE_X: normal = vec3(0.5, 0, 0); break;
		//case FACE_NX: normal = vec3(0.5, 0.5, 0); break;
		case FACE_Y: normal = vec3(0, 0.5, 0); break;
		//case FACE_NY: normal = vec3(0, 0.5, 0.5); break;
		case FACE_Z: normal = vec3(0, 0, 0.5); break;
		//case FACE_NZ: normal = vec3(0.5, 0, 0.5); break;
	}

	chunk_vertex_buffer.chunk_vertex[v + 0] = chunk_vertex_t(vec4(p0, 1), vec4(normal, 1)); // TODO: add face back in..
	chunk_vertex_buffer.chunk_vertex[v + 1] = chunk_vertex_t(vec4(p1, 1), vec4(normal, 1)); // TODO: add face back in..
	chunk_vertex_buffer.chunk_vertex[v + 2] = chunk_vertex_t(vec4(p2, 1), vec4(normal, 1)); // TODO: add face back in..
	chunk_vertex_buffer.chunk_vertex[v + 3] = chunk_vertex_t(vec4(p3, 1), vec4(normal, 1)); // TODO: add face back in..

	switch (face) {
		case FACE_X: {

			chunk_index_buffer.chunk_index[i + 0] = v + 0;
			chunk_index_buffer.chunk_index[i + 1] = v + 2;
			chunk_index_buffer.chunk_index[i + 2] = v + 1;
			chunk_index_buffer.chunk_index[i + 3] = v + 0;
			chunk_index_buffer.chunk_index[i + 4] = v + 3;
			chunk_index_buffer.chunk_index[i + 5] = v + 2;

			break;
		}
		//case FACE_NX: {
		//
		//	chunk_index_buffer.chunk_index[i + 0] = v + 0;
		//	chunk_index_buffer.chunk_index[i + 1] = v + 1;
		//	chunk_index_buffer.chunk_index[i + 2] = v + 2;
		//	chunk_index_buffer.chunk_index[i + 3] = v + 0;
		//	chunk_index_buffer.chunk_index[i + 4] = v + 2;
		//	chunk_index_buffer.chunk_index[i + 5] = v + 3;
		//
		//	break;
		//}
		case FACE_Y: {

			chunk_index_buffer.chunk_index[i + 0] = v + 0;
			chunk_index_buffer.chunk_index[i + 1] = v + 1;
			chunk_index_buffer.chunk_index[i + 2] = v + 2;
			chunk_index_buffer.chunk_index[i + 3] = v + 0;
			chunk_index_buffer.chunk_index[i + 4] = v + 2;
			chunk_index_buffer.chunk_index[i + 5] = v + 3;

			break;
		}
		//case FACE_NY: {
		//
		//	chunk_index_buffer.chunk_index[i + 0] = v + 0;
		//	chunk_index_buffer.chunk_index[i + 1] = v + 2;
		//	chunk_index_buffer.chunk_index[i + 2] = v + 1;
		//	chunk_index_buffer.chunk_index[i + 3] = v + 0;
		//	chunk_index_buffer.chunk_index[i + 4] = v + 3;
		//	chunk_index_buffer.chunk_index[i + 5] = v + 2;
		//
		//	break;
		//}
		case FACE_Z: {

			chunk_index_buffer.chunk_index[i + 0] = v + 0;
			chunk_index_buffer.chunk_index[i + 1] = v + 2;
			chunk_index_buffer.chunk_index[i + 2] = v + 1;
			chunk_index_buffer.chunk_index[i + 3] = v + 0;
			chunk_index_buffer.chunk_index[i + 4] = v + 3;
			chunk_index_buffer.chunk_index[i + 5] = v + 2;

			break;
		}
		//case FACE_NZ: {
		//
		//	chunk_index_buffer.chunk_index[i + 0] = v + 0;
		//	chunk_index_buffer.chunk_index[i + 1] = v + 1;
		//	chunk_index_buffer.chunk_index[i + 2] = v + 2;
		//	chunk_index_buffer.chunk_index[i + 3] = v + 0;
		//	chunk_index_buffer.chunk_index[i + 4] = v + 2;
		//	chunk_index_buffer.chunk_index[i + 5] = v + 3;
		//
		//	break;
		//}
	}
}

uint load_mask(uint face, uint slice, uint row) {
	uint idx = slice * CHUNK_PAD + row;

	switch (face) {
		case FACE_X: return chunk_mask_buffer.chunk_mask[pc.chunk_index].opaque_x_mask[idx];
		case FACE_Y: return chunk_mask_buffer.chunk_mask[pc.chunk_index].opaque_y_mask[idx];
		case FACE_Z: return chunk_mask_buffer.chunk_mask[pc.chunk_index].opaque_z_mask[idx];
	}

	return 0;
}

ivec3 logical_to_world(uint face, uint slice, uint y, uint z) {
	switch (face) {
		case FACE_X: return ivec3(slice + 1, y, z);
		case FACE_Y: return ivec3(y, slice + 1, z);
		case FACE_Z: return ivec3(y, z, slice + 1);
	}

	return ivec3(0);
}

void greedy_mesh(uint face, uint slice) {
	uint rows[CHUNK_PAD];

	for (uint y = 0; y < CHUNK_PAD; y++) {
		rows[y] = load_mask(face, slice, y);
	}

	for (uint y = 0; y < CHUNK_PAD; y++) {

		uint row = rows[y];

		//if (face == FACE_PZ) {
		//	row |= (1u << 0);                 // clear boundary at 0
		//	row |= (1u << (CHUNK_SIZE-1));    // clear boundary at CHUNK_SIZE
		//}

		row &= ~(1u << 0);                 // clear boundary at 0
		row &= ~(1u << (CHUNK_SIZE-1));    // clear boundary at CHUNK_SIZE

		while (row != 0) {

			uint z0 = findLSB(row);

			uint z1 = z0;
			while (z1 + 1 < CHUNK_SIZE && ((row >> (z1 + 1)) & 1u) == 1u) {
				z1++;
			}

			uint width = z1 - z0 + 1;
			uint width_mask = ((1u << width) - 1u) << z0;

			uint y1 = y;
			while (y1 + 1 < CHUNK_SIZE && (rows[y1 + 1] & width_mask) == width_mask) {
				y1++;
			}

			uint height = y1 - y + 1;

			for (uint yy = y; yy <= y1; yy++) {
				rows[yy] &= ~width_mask;
			}

			ivec3 p0 = logical_to_world(face, slice, y, z0);
			ivec3 p1 = logical_to_world(face, slice, y, z0 + width);
			ivec3 p2 = logical_to_world(face, slice, y + height, z0 + width);
			ivec3 p3 = logical_to_world(face, slice, y + height, z0);

			emit_quad(p0, p1, p2, p3, face);

			row = rows[y];
		}
	}
}

void main() {
	uint slice = gl_GlobalInvocationID.x;
	uint face = gl_GlobalInvocationID.z;

	greedy_mesh(face, slice);
}