#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../vdb/common.glsl"

const uint MAX_RAY_STEPS = 1000;

layout (
	local_size_x = 1,
	local_size_y = 1,
	local_size_z = 1
) in;

layout (binding = 0) uniform camera_info_t {
	vec3 position;
	float reserved0;
	mat4 view;
	mat4 projection;
	mat4 view_projection;
	mat4 view_projection_inv;
	vec4 frustum_plane[6];
} camera_info;
layout (binding = 1) uniform cluster_info_t {
	ivec2 dimension;
} cluster_info;
layout (binding = 2) uniform screen_info_t {
	ivec2 resolution;
} screen_info;
layout (binding = 3) uniform mouse_info_t {
	ivec2 position;
} mouse_info;
layout (binding = 4, r32ui) uniform uimage3D chunk_data[];
layout (binding = 5, std430) writeonly buffer trace_result_buffer_t {
	ivec3 voxel_position;
	int intersection;
} trace_result_buffer;

uint get_voxel(ivec3 voxel_position) {
	return uint(imageLoad(chunk_data[0], voxel_position).r);
}
void set_voxel(ivec3 voxel_position, uint voxel) {
	imageStore(chunk_data[0], voxel_position, uvec4(voxel, 0, 0, 0));
}

void dda_trace(vec3 ray_origin, vec3 ray_direction, inout vec3 hit_voxel, inout bool intersection) {
	vec3 ray_direction_inv = 1.0 / ray_direction;
	vec3 ray_direction_sign = sign(ray_direction);

	vec3 sample_position = floor(ray_origin);
	vec3 side_distance = (sample_position - ray_origin + 0.5 + ray_direction_sign * 0.5) * ray_direction_inv;

	uint ray_step_index = 0;

	while (ray_step_index < MAX_RAY_STEPS)
	{
		uint voxel = get_voxel(ivec3(sample_position));

		if (VOXEL_IS_SOLID(voxel))
		{
			intersection = true;

			break;
		}

		vec3 mask = step(side_distance.xyz, side_distance.yzx) * step(side_distance.xyz, side_distance.zxy);

		sample_position += mask * ray_direction_sign;
		side_distance += mask * ray_direction_sign * ray_direction_inv;

		ray_step_index++;
	}

	hit_voxel = sample_position;
}

void main() {
	ivec3 chunk_position = ivec3(0); // TODO

	float mouse_ndc_x = (2 * float(mouse_info.position.x)) / float(screen_info.resolution.x) - 1;
	float mouse_ndc_y = 1 - (2 * float(mouse_info.position.y)) / float(screen_info.resolution.y);

	vec4 ray_clip_near = vec4(mouse_ndc_x, mouse_ndc_y, -1, 1);
	vec4 ray_clip_far = vec4(mouse_ndc_x, mouse_ndc_y,  1, 1);

	vec4 ray_world_near = camera_info.view_projection_inv * ray_clip_near;
	vec4 ray_world_far = camera_info.view_projection_inv * ray_clip_far;

	ray_world_near /= ray_world_near.w;
	ray_world_far /= ray_world_far.w;

	vec3 ray_origin = ray_world_near.xyz;
	vec3 ray_direction = normalize(ray_world_far.xyz - ray_world_near.xyz);

	vec3 hit_voxel = vec3(0);
	bool intersection = false;

	dda_trace(ray_origin, ray_direction, hit_voxel, intersection);

	trace_result_buffer.voxel_position = ivec3(hit_voxel);
	trace_result_buffer.intersection = int(intersection);

	// TODO: put ray_origin and ray_direction into trace_result_buffer and check on CPU..
}