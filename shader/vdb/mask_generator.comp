#version 460 core

#extension GL_ARB_shading_language_include : require

#include "../math/utility.glsl"

#include "../noise/cellular.glsl"
#include "../noise/curl.glsl"
#include "../noise/fbm.glsl"
#include "../noise/gradient.glsl"
#include "../noise/perlin.glsl"
#include "../noise/simplex.glsl"

#include "../vdb/common.glsl"

layout (local_size_x = 8) in;
layout (local_size_y = 8) in;
layout (local_size_z = 8) in;

layout(binding = 2) writeonly buffer vdb_chunk_mask_buffer_t {
    vdb_chunk_mask_t chunk_mask[];
} vdb_chunk_mask_buffer;

layout(push_constant) uniform vdb_world_generator_push_constant_t {
    ivec3 chunk_position;
    int   chunk_index;
} pc;

int get_chunk_index(ivec3 p) {
    ivec3 c = ivec3(VDB_CLUSTER_DIM_X, VDB_CLUSTER_DIM_Y, VDB_CLUSTER_DIM_Z);
    if (any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, c))) return -1;
    return p.x + p.y * c.x + p.z * c.x * c.y;
}

float vdb_default_density(vec3 sample_position, float ground_level, float cluster_height) {
	float density = 0.0;

	density += noise_cellular_t1((sample_position + vec3(131.0, 11.0, 141.0)) * 0.115, 2.9, 0.3) * 2.44;
	density += noise_curl_t1((sample_position + vec3(887.0, 358.0, 262.0)) * 0.006).x * 14.13;
	density += noise_curl_t1((sample_position + vec3(32.0, 288.0, 204.0)) * 0.045).x * 2.04;

	float norm_y = sample_position.y / cluster_height;
	float height_thresh = ground_level / cluster_height;

	float blend = 1.0 - smoothstep(height_thresh - 0.4, height_thresh + 0.2, norm_y);

	density *= blend;

	//density = soft_terrace(density, 5, 10.0);

	return density;
}

void main() {

    ivec3 local = ivec3(gl_GlobalInvocationID) - ivec3(1);

    if (any(lessThan(local, ivec3(-1))) ||
        any(greaterThan(local, ivec3(VDB_CHUNK_SIZE))))
        return;

    ivec3 chunk = pc.chunk_position;
    int cidx = pc.chunk_index;

    vec3 p = vec3(chunk * VDB_CHUNK_SIZE + local);

	float ground_level = float(VDB_CLUSTER_DIM_Y * VDB_CHUNK_SIZE) / 2.0;
	float cluster_height = float(VDB_CLUSTER_DIM_Y * VDB_CHUNK_SIZE);

    float d  = vdb_default_density(p, ground_level, cluster_height);
    if (d <= VDB_SURFACE_THRESHOLD) return;

    float dxp = vdb_default_density(p + vec3(1,0,0), ground_level, cluster_height);
    float dxn = vdb_default_density(p + vec3(-1,0,0), ground_level, cluster_height);
    float dyp = vdb_default_density(p + vec3(0,1,0), ground_level, cluster_height);
    float dyn = vdb_default_density(p + vec3(0,-1,0), ground_level, cluster_height);
    float dzp = vdb_default_density(p + vec3(0,0,1), ground_level, cluster_height);
    float dzn = vdb_default_density(p + vec3(0,0,-1), ground_level, cluster_height);

    uint x = uint(clamp(local.x, 0, VDB_CHUNK_SIZE - 1));
    uint y = uint(clamp(local.y, 0, VDB_CHUNK_SIZE - 1));
    uint z = uint(clamp(local.z, 0, VDB_CHUNK_SIZE - 1));

    uint idx_yz = 1u + y + z * VDB_CHUNK_SIZE;
    uint idx_xz = 1u + x + z * VDB_CHUNK_SIZE;
    uint idx_xy = 1u + x + y * VDB_CHUNK_SIZE;

    // +X
    if (dxp <= VDB_SURFACE_THRESHOLD) {
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].px_mask[idx_yz], 1u << x);
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].any_px_faces, 1u << x);
    }

    // -X
    if (dxn <= VDB_SURFACE_THRESHOLD) {
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].nx_mask[idx_yz], 1u << x);
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].any_nx_faces, 1u << x);
    }

    // +Y
    if (dyp <= VDB_SURFACE_THRESHOLD) {
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].py_mask[idx_xz], 1u << y);
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].any_py_faces, 1u << y);
    }

    // -Y
    if (dyn <= VDB_SURFACE_THRESHOLD) {
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].ny_mask[idx_xz], 1u << y);
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].any_ny_faces, 1u << y);
    }

    // +Z
    if (dzp <= VDB_SURFACE_THRESHOLD) {
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].pz_mask[idx_xy], 1u << z);
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].any_pz_faces, 1u << z);
    }

    // -Z
    if (dzn <= VDB_SURFACE_THRESHOLD) {
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].nz_mask[idx_xy], 1u << z);
        atomicOr(vdb_chunk_mask_buffer.chunk_mask[cidx].any_nz_faces, 1u << z);
    }
}