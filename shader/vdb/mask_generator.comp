#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../vdb/common.glsl"

layout (
	local_size_x = 1,
	local_size_y = 1,
	local_size_z = 1
) in;

layout (binding = 0, r32ui) uniform uimage3D chunk_data[];
layout (binding = 1, std430) writeonly buffer chunk_mask_buffer_t {
	chunk_mask_t chunk_mask[];
} chunk_mask_buffer;

layout (push_constant) uniform push_constant_t {
	ivec3 chunk_position;
	uint chunk_index;
} pc;

uint get_voxel(ivec3 chunk_position, ivec3 voxel_position) {
	uint voxel = EMPTY_VOXEL;

	if (voxel_position.x >= CHUNK_SIZE) {
		chunk_position.x++;
		voxel_position.x = 0;
	}

	if (voxel_position.y >= CHUNK_SIZE) {
		chunk_position.y++;
		voxel_position.y = 0;
	}

	if (voxel_position.z >= CHUNK_SIZE) {
		chunk_position.z++;
		voxel_position.z = 0;
	}

	if (all(lessThan(chunk_position, CLUSTER_SIZE))) {
		
		uint chunk_index = (chunk_position.x) + (chunk_position.y * CLUSTER_DIM_X) + (chunk_position.z * CLUSTER_DIM_X * CLUSTER_DIM_Y);

		voxel = uint(imageLoad(chunk_data[chunk_index], voxel_position).r);
	}

	return voxel;
}

void main() {
	uint slice = gl_GlobalInvocationID.x;
	uint row = gl_GlobalInvocationID.y;
	uint face = gl_GlobalInvocationID.z;

	uint mask = 0u;

	for (uint bit = 0; bit < CHUNK_SIZE; bit++) {

		ivec3 p, n;

		switch (face) {
			case FACE_X:
				p = ivec3(slice, row, bit);
				n = p + ivec3(1, 0, 0);
				break;
			case FACE_Y:
				p = ivec3(row, slice, bit);
				n = p + ivec3(0, 1, 0);
				break;
			case FACE_Z:
				p = ivec3(row, bit, slice);
				n = p + ivec3(0, 0, 1);
				break;
		}

		uint v = get_voxel(pc.chunk_position, p);
		uint vn = get_voxel(pc.chunk_position, n);

		if (VOXEL_IS_SOLID(v) && VOXEL_IS_EMPTY(vn)) {
			mask |= (1u << bit);
		}
	}

	uint idx = slice * CHUNK_PAD + row;

	switch (face) {
		case FACE_X: chunk_mask_buffer.chunk_mask[pc.chunk_index].opaque_x_mask[idx] = mask; break;
		case FACE_Y: chunk_mask_buffer.chunk_mask[pc.chunk_index].opaque_y_mask[idx] = mask; break;
		case FACE_Z: chunk_mask_buffer.chunk_mask[pc.chunk_index].opaque_z_mask[idx] = mask; break;
	}
}