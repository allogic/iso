#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_mesh_shader : require

#include "../vdb/common.glsl"

const float TILE_SIZE = 0.5;
const float TILE_HEIGHT = 0.5;

const float DEPTH_SCALE = 0.001;
const float DEPTH_EPS = 0.00001;

layout (local_size_x = 4) in;
layout (local_size_y = 1) in;
layout (local_size_z = 4) in;

layout (triangles) out;
layout (max_vertices = 192) out;
layout (max_primitives = 96) out;

layout (location = 0) out vec3 output_color[];
layout (location = 1) out vec2 output_uv[];

layout (binding = 0) uniform camera_info_t {
	vec3 position;
	float reserved0;
	mat4 view;
	mat4 projection;
	mat4 view_projection;
	mat4 view_projection_inv;
	vec4 frustum_plane[6];
} camera_info;
layout (binding = 1) uniform usampler3D vdb_chunk;

taskPayloadSharedEXT vdb_payload_t vdb_payload;

uint get_voxel(ivec3 voxel_position) {
	return uint(texelFetch(vdb_chunk, voxel_position, 0).r);
}

float base_depth(vec3 p) {
	return (p.x + p.z + p.y) * DEPTH_SCALE;
}

vec3 iso_project(vec3 p, float depth_bias) {
	float iso_x = p.x - p.z;
	float iso_y = (p.x + p.z) * 0.5 - p.y;
	float iso_z = base_depth(p) + depth_bias;

	return vec3(iso_x, iso_y, iso_z);
}

void emit_quad(uint v, uint t, vec3 a, vec3 b, vec3 c, vec3 d, float depth_bias, vec3 color) {
	gl_MeshVerticesEXT[v + 0].gl_Position = camera_info.view_projection * vec4(iso_project(a, depth_bias), 1);
	gl_MeshVerticesEXT[v + 1].gl_Position = camera_info.view_projection * vec4(iso_project(b, depth_bias), 1);
	gl_MeshVerticesEXT[v + 2].gl_Position = camera_info.view_projection * vec4(iso_project(c, depth_bias), 1);
	gl_MeshVerticesEXT[v + 3].gl_Position = camera_info.view_projection * vec4(iso_project(d, depth_bias), 1);

	output_color[v + 0] = color;
	output_color[v + 1] = color;
	output_color[v + 2] = color;
	output_color[v + 3] = color;

	output_uv[v + 0] = vec2(0.0, 0.0);
	output_uv[v + 1] = vec2(1.0, 0.0);
	output_uv[v + 2] = vec2(1.0, 1.0);
	output_uv[v + 3] = vec2(0.0, 1.0);

	gl_PrimitiveTriangleIndicesEXT[t + 0] = uvec3(v + 0, v + 1, v + 2);
	gl_PrimitiveTriangleIndicesEXT[t + 1] = uvec3(v + 2, v + 3, v + 0);
}

void emit_tile(uint tile, vec3 voxel_position) {
	float s = TILE_SIZE;
	float h = TILE_HEIGHT;

	vec3 world_base = vec3(
		voxel_position.x * s,
		voxel_position.y * h,
		voxel_position.z * s
	);

	uint v = tile * 12;
	uint t = tile * 6;

	float depth_top  = base_depth(voxel_position) - DEPTH_EPS;
	float depth_side = base_depth(voxel_position) + DEPTH_EPS;

	emit_quad(
		v + 0, t + 0,
		world_base + vec3(0, 0, s),
		world_base + vec3(s, 0, s),
		world_base + vec3(s, 0, 0),
		world_base + vec3(0, 0, 0),
		depth_top,
		vec3(0.8, 0.9, 1.0)
	);

	emit_quad(
		v + 4, t + 2,
		world_base + vec3(0, 0, 0),
		world_base + vec3(s, 0, 0),
		world_base + vec3(s, h, 0),
		world_base + vec3(0, h, 0),
		depth_side,
		vec3(0.55, 0.7, 0.9)
	);

	emit_quad(
		v + 8, t + 4,
		world_base + vec3(0, 0, s),
		world_base + vec3(0, 0, 0),
		world_base + vec3(0, h, 0),
		world_base + vec3(0, h, s),
		depth_side,
		vec3(0.45, 0.6, 0.85)
	);
}

void main() {
	int block_base_x = int(gl_WorkGroupID.x) * 4;
	int block_base_y = (VDB_CHUNK_SIZE - 1) - int(gl_WorkGroupID.y);
	int block_base_z = int(gl_WorkGroupID.z) * 4;

	uint tile_counter = 0;

	for (int z = 3; z >= 0; z--) {
		for (int x = 3; x >= 0; x--) {

			ivec3 voxel_position = ivec3(block_base_x + x, block_base_y, block_base_z + z);

			uint voxel = get_voxel(voxel_position);

			if (VDB_VOXEL_IS_SOLID(voxel)) {
				emit_tile(tile_counter, voxel_position);

				tile_counter++;
			}
		}
	}

	SetMeshOutputsEXT(tile_counter * 12, tile_counter * 6);
}