#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../noise/cellular.glsl"
#include "../noise/curl.glsl"
#include "../noise/fbm.glsl"
#include "../noise/gradient.glsl"
#include "../noise/perlin.glsl"
#include "../noise/simplex.glsl"

#include "../vdb/common.glsl"

layout (
	local_size_x = 8,
	local_size_y = 8,
	local_size_z = 8
) in;

layout (binding = 0) uniform cluster_info_t {
	ivec2 dimension;
} cluster_info;
layout (binding = 1, r32ui) uniform uimage3D chunk_data[];

uint get_voxel(ivec3 voxel_position) {
	return uint(imageLoad(chunk_data[0], voxel_position).r);
}
void set_voxel(ivec3 voxel_position, uint voxel) {
	imageStore(chunk_data[0], voxel_position, uvec4(voxel, 0, 0, 0));
}

float default_terrain_density(vec3 sample_position, float ground_level, float cluster_height) {
	float density = 0.0;

	density += noise_cellular_t1((sample_position + vec3(131.0, 11.0, 141.0)) * 0.115, 2.9, 0.3) * 2.44;
	density += noise_curl_t1((sample_position + vec3(887.0, 358.0, 262.0)) * 0.006).x * 14.13;
	density += noise_curl_t1((sample_position + vec3(32.0, 288.0, 204.0)) * 0.045).x * 2.04;

	float norm_y = sample_position.y / cluster_height;
	float height_thresh = ground_level / cluster_height;

	float blend = smoothstep(height_thresh + 0.3, height_thresh - 0.3, norm_y);

	density *= blend;

	//density = soft_terrace(density, 5, 10.0);

	return density;
}

void main() {
	ivec3 chunk_position = ivec3(0); // TODO
	ivec3 voxel_position = ivec3(gl_GlobalInvocationID.xyz);
	
	vec3 sample_position = vec3((chunk_position * CHUNK_SIZE) + voxel_position);

	float cluster_height = CHUNK_SIZE;
	float ground_level = cluster_height / 2.0;

	float density  = default_terrain_density(sample_position, ground_level, cluster_height);

	uint voxel = EMPTY_VOXEL;

	if (density <= SURFACE_THRESHOLD) {
		voxel = VOXEL_SET_SOLID(voxel);
	}

	set_voxel(voxel_position, voxel);
}