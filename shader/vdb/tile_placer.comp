#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../vdb/common.glsl"

layout (
	local_size_x = 1,
	local_size_y = 1,
	local_size_z = 1
) in;

layout (binding = 0) uniform cluster_info_t {
	ivec2 dimension;
} cluster_info;
layout (binding = 1) uniform place_info_t {
	ivec3 tile_position;
	uint tile_id;
} place_info;
layout (binding = 2, r32ui) uniform uimage3D chunk_data[];
layout (binding = 3) readonly buffer tile_lut_buffer_t {
	tile_t tile_lut[];
} tile_lut_buffer;
layout (binding = 4) buffer place_result_buffer_t {
	uint is_obstructed;
} place_result_buffer;

uint get_voxel(ivec3 voxel_position) {
	return uint(imageLoad(chunk_data[0], voxel_position).r);
}
void set_voxel(ivec3 voxel_position, uint voxel) {
	imageStore(chunk_data[0], voxel_position, uvec4(voxel, 0, 0, 0));
}

void main() {
	ivec3 chunk_position = ivec3(0); // TODO

	tile_t tile = tile_lut_buffer.tile_lut[place_info.tile_id];

	uint is_obstructed = 0;

	for (uint z = 0; z < tile.tile_size_z; z++) {
		for (uint x = 0; x < tile.tile_size_x; x++) {
			
			ivec3 voxel_position = place_info.tile_position + ivec3(x, 0, z);

			uint voxel = get_voxel(voxel_position);

			if (VOXEL_IS_SOLID(voxel)) {
				is_obstructed |= 1;
			}
		}
	}

	if (is_obstructed == 0) {

		ivec3 voxel_position = place_info.tile_position;

		uint tile_id = place_info.tile_id;

		uint voxel = EMPTY_VOXEL;

		voxel = VOXEL_SET_SOLID(voxel);
		voxel = VOXEL_SET_TILE_ID(voxel, tile_id);

		set_voxel(voxel_position, voxel);
	}

	place_result_buffer.is_obstructed = is_obstructed;
}