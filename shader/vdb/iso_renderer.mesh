#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_mesh_shader : require

#include "../vdb/common.glsl"

const float TILE_SIZE = 1.0;
const float TILE_HEIGHT = 0.5;

const float DEPTH_SCALE = 0.001;
const float DEPTH_EPS = 0.00001;

layout (
	local_size_x = 4,
	local_size_y = 1,
	local_size_z = 4
) in;

layout (
	triangles,
	max_vertices = 192,
	max_primitives = 96
) out;

layout (location = 0) out vec3 output_color[];
layout (location = 1) out vec2 output_uv[];
layout (location = 2) out uint output_tile_index[];

layout (binding = 0) uniform camera_info_t {
	vec3 position;
	float reserved0;
	mat4 view;
	mat4 projection;
	mat4 view_projection;
	mat4 view_projection_inv;
	vec4 frustum_plane[6];
} camera_info;
layout (binding = 1) uniform usampler3D chunk_data[];

layout (push_constant) uniform push_constant_t {
	vec4 vertex_offset_0;
	vec4 vertex_offset_1;
	vec4 vertex_offset_2;
	vec4 vertex_offset_3;
	float tile_size;
	float tile_height;
	float depth_scale;
	float depth_eps;
} pc;

taskPayloadSharedEXT payload_t payload;

uint get_voxel(ivec3 voxel_position) {
	return uint(texelFetch(chunk_data[0], voxel_position, 0).r);
}

float base_depth(vec3 p) {
	return (p.x + p.z + p.y) * pc.depth_scale; // DEPTH_SCALE;
}

vec3 iso_project(vec3 p, float depth_bias) {
	float iso_x = p.x - p.z;
	float iso_y = (p.x + p.z) * 0.5 - p.y;
	float iso_z = base_depth(p) + depth_bias;

	return vec3(iso_x, iso_y, iso_z);
}
vec3 flat_project(vec3 p, float depth_bias) {
	float screen_x = p.x;
	float screen_y = p.z;
	float screen_z = p.y * 0.7 + (p.x + p.z) * 0.04;

	return vec3(screen_x, screen_y, screen_z + depth_bias);
}

void emit_flat_quad(uint v, uint t, vec3 a, vec3 b, vec3 c, vec3 d, float depth_bias, vec3 color) {
	gl_MeshVerticesEXT[v + 0].gl_Position = camera_info.view_projection * vec4(flat_project(a, depth_bias), 1);
	gl_MeshVerticesEXT[v + 1].gl_Position = camera_info.view_projection * vec4(flat_project(b, depth_bias), 1);
	gl_MeshVerticesEXT[v + 2].gl_Position = camera_info.view_projection * vec4(flat_project(c, depth_bias), 1);
	gl_MeshVerticesEXT[v + 3].gl_Position = camera_info.view_projection * vec4(flat_project(d, depth_bias), 1);

	output_color[v + 0] = color;
	output_color[v + 1] = color;
	output_color[v + 2] = color;
	output_color[v + 3] = color;

	output_uv[v + 0] = vec2(0.0, 0.0);
	output_uv[v + 1] = vec2(1.0, 0.0);
	output_uv[v + 2] = vec2(1.0, 1.0);
	output_uv[v + 3] = vec2(0.0, 1.0);

	output_tile_index[v + 0] = 0;
	output_tile_index[v + 1] = 0;
	output_tile_index[v + 2] = 0;
	output_tile_index[v + 3] = 0;

	gl_PrimitiveTriangleIndicesEXT[t + 0] = uvec3(v + 0, v + 1, v + 2);
	gl_PrimitiveTriangleIndicesEXT[t + 1] = uvec3(v + 2, v + 3, v + 0);
}

void emit_quad(uint v, uint t, vec3 a, vec3 b, vec3 c, vec3 d, float depth_bias, vec3 color) {
	gl_MeshVerticesEXT[v + 0].gl_Position = camera_info.view_projection * vec4(iso_project(a, depth_bias), 1);
	gl_MeshVerticesEXT[v + 1].gl_Position = camera_info.view_projection * vec4(iso_project(b, depth_bias), 1);
	gl_MeshVerticesEXT[v + 2].gl_Position = camera_info.view_projection * vec4(iso_project(c, depth_bias), 1);
	gl_MeshVerticesEXT[v + 3].gl_Position = camera_info.view_projection * vec4(iso_project(d, depth_bias), 1);

	output_color[v + 0] = color;
	output_color[v + 1] = color;
	output_color[v + 2] = color;
	output_color[v + 3] = color;

	output_uv[v + 0] = vec2(0.0, 0.0);
	output_uv[v + 1] = vec2(1.0, 0.0);
	output_uv[v + 2] = vec2(1.0, 1.0);
	output_uv[v + 3] = vec2(0.0, 1.0);

	output_tile_index[v + 0] = 1;
	output_tile_index[v + 1] = 1;
	output_tile_index[v + 2] = 1;
	output_tile_index[v + 3] = 1;

	gl_PrimitiveTriangleIndicesEXT[t + 0] = uvec3(v + 0, v + 1, v + 2);
	gl_PrimitiveTriangleIndicesEXT[t + 1] = uvec3(v + 2, v + 3, v + 0);
}

void emit_tile(uint tile, vec3 voxel_position) {
	float s = pc.tile_size; // TILE_SIZE;
	float h = pc.tile_height; // TILE_HEIGHT;

	vec3 world_base = vec3(
		voxel_position.x * s,
		voxel_position.y * h,
		voxel_position.z * s
	);

	uint v = tile * 12;
	uint t = tile * 6;

	float depth_top  = base_depth(voxel_position) - pc.depth_eps; // DEPTH_EPS;
	float depth_side = base_depth(voxel_position) + pc.depth_eps; // DEPTH_EPS;

	emit_quad(
		v + 0, t + 0,
		world_base + vec3(0, 0, s) + vec3(-1, -2, 0),
		world_base + vec3(s, 0, s) + vec3(2, 0, 0),
		world_base + vec3(s, 0, 0) + vec3(1, 3, 0),
		world_base + vec3(0, 0, 0) + vec3(-2, 1, 0),
		depth_top,
		vec3(0.8, 0.9, 1.0)
	);

	emit_quad(
		v + 4, t + 2,
		world_base + vec3(0, 0, s) + vec3(-1, -2, 0),
		world_base + vec3(s, 0, s) + vec3(2, 0, 0),
		world_base + vec3(s, 0, 0) + vec3(1, 3, 0),
		world_base + vec3(0, 0, 0) + vec3(-2, 1, 0),
		depth_top,
		vec3(0.8, 0.9, 1.0)
	);

	emit_quad(
		v + 8, t + 4,
		world_base + vec3(0, 0, s) + vec3(-1, -2, 0),
		world_base + vec3(s, 0, s) + vec3(2, 0, 0),
		world_base + vec3(s, 0, 0) + vec3(1, 3, 0),
		world_base + vec3(0, 0, 0) + vec3(-2, 1, 0),
		depth_top,
		vec3(0.8, 0.9, 1.0)
	);

	//emit_quad(
	//	v + 0, t + 0,
	//	world_base + vec3(0, 0, s) + pc.vertex_offset_0.xyz,
	//	world_base + vec3(s, 0, s) + pc.vertex_offset_1.xyz,
	//	world_base + vec3(s, 0, 0) + pc.vertex_offset_2.xyz,
	//	world_base + vec3(0, 0, 0) + pc.vertex_offset_3.xyz,
	//	depth_top,
	//	vec3(0.8, 0.9, 1.0)
	//);

	//emit_quad(
	//	v + 4, t + 2,
	//	world_base + vec3(0, 0, 0),
	//	world_base + vec3(s, 0, 0),
	//	world_base + vec3(s, h, 0),
	//	world_base + vec3(0, h, 0),
	//	depth_side,
	//	vec3(0.55, 0.7, 0.9)
	//);

	//emit_quad(
	//	v + 8, t + 4,
	//	world_base + vec3(0, 0, s),
	//	world_base + vec3(0, 0, 0),
	//	world_base + vec3(0, h, 0),
	//	world_base + vec3(0, h, s),
	//	depth_side,
	//	vec3(0.45, 0.6, 0.85)
	//);
}

void main() {
	int block_base_x = int(gl_WorkGroupID.x) * 4;
	int block_base_y = (CHUNK_SIZE - 1) - int(gl_WorkGroupID.y);
	int block_base_z = int(gl_WorkGroupID.z) * 4;

	uint tile_counter = 0;

	ivec3 voxel_position = ivec3(block_base_x, block_base_y, block_base_z);

	uint voxel = get_voxel(voxel_position);

	if (VOXEL_IS_SOLID(voxel)) {

		emit_tile(tile_counter, voxel_position);

		tile_counter++;
	}

	//for (int z = 3; z >= 0; z--) {
	//	for (int x = 3; x >= 0; x--) {
	//
	//		ivec3 voxel_position = ivec3(block_base_x + x, block_base_y, block_base_z + z);
	//
	//		uint voxel = get_voxel(voxel_position);
	//
	//		if (VOXEL_IS_SOLID(voxel)) {
	//
	//			emit_tile(tile_counter, voxel_position);
	//
	//			tile_counter++;
	//		}
	//	}
	//}

	SetMeshOutputsEXT(tile_counter * 12, tile_counter * 6);
}