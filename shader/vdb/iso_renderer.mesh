#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_mesh_shader : require

#include "../vdb/common.glsl"

const float ISO_X_SCALE = 16.0;
const float ISO_Y_SCALE = 8.0;
const float ISO_Y_HEIGHT = 16.0;

const float DEPTH_SCALE = 0.001;

layout (
	local_size_x = 8,
	local_size_y = 1,
	local_size_z = 8
) in;

layout (
	triangles,
	max_vertices = 256,
	max_primitives = 128
) out;

layout (location = 0) out vec3 output_color[];
layout (location = 1) out vec2 output_uv[];
layout (location = 2) out uint output_atlas_id[];

layout (binding = 0) uniform player_info_t {
	vec3 position;
} player_info;
layout (binding = 1) uniform camera_info_t {
	vec2 position;
	float zoom;
} camera_info;
layout (binding = 2) uniform screen_info_t {
	ivec2 resolution;
} screen_info;
layout (binding = 3) uniform usampler3D chunk_data[];
layout (binding = 4) readonly buffer tile_lut_buffer_t {
	tile_t tile_lut[];
} tile_lut_buffer;

layout (push_constant) uniform push_constant_t {
	vec4 vertex_offset_0;
	vec4 vertex_offset_1;
	vec4 vertex_offset_2;
	vec4 vertex_offset_3;
	vec4 rotation;
	float tile_size;
	float tile_height;
	float inner_scale;
	float outer_scale;
} pc;

taskPayloadSharedEXT payload_t payload;

uint get_voxel(ivec3 voxel_position) {
	return uint(texelFetch(chunk_data[0], voxel_position, 0).r);
}

void iso_screen_to_world(float screen_position_x, float screen_position_y, float camera_position_x, float camera_position_y, inout float world_position_x, inout float world_position_z) {
	screen_position_x -= camera_position_x;
	screen_position_y -= camera_position_y;

	world_position_x = ((screen_position_x / ISO_X_SCALE) + (screen_position_y / ISO_Y_SCALE)) * 0.5;
	world_position_z = ((screen_position_y / ISO_Y_SCALE) - (screen_position_x / ISO_X_SCALE)) * 0.5;
}
void iso_world_to_screen(float world_position_x, float world_position_y, float world_position_z, float camera_position_x, float camera_position_y, inout float screen_position_x, inout float screen_position_y) {
	screen_position_x = world_position_x * ISO_X_SCALE + world_position_z * -ISO_X_SCALE + camera_position_x;
	screen_position_y = world_position_x * ISO_Y_SCALE + world_position_z * ISO_Y_SCALE - world_position_y * ISO_Y_HEIGHT + camera_position_y;
};

float iso_depth(vec3 position) {
	return (position.x + position.z + position.y) * DEPTH_SCALE;
}

vec2 to_clip(vec2 position, ivec2 screen_resolution) {
	vec2 ndc = (position / screen_resolution) * 2 - 1;

	ndc.y = -ndc.y;

	return ndc;
}

void emit_tile(uint tile_counter, vec3 voxel_position, uint tile_id) {
	tile_t tile = tile_lut_buffer.tile_lut[tile_id];

	float screen_space_x = 0;
	float screen_space_y = 0;

	iso_world_to_screen(voxel_position.x, voxel_position.y, voxel_position.z, camera_info.position.x, camera_info.position.y, screen_space_x, screen_space_y);

	//vec2 pivot = vec2(screen_info.resolution) * 0.5;
	//
	//screen_space_x = pivot.x + (screen_space_x - pivot.x) * camera_info.zoom;
	//screen_space_y = pivot.y + (screen_space_y - pivot.y) * camera_info.zoom;

	float depth = iso_depth(voxel_position);

	float w = float(tile.width); // * camera_info.zoom;
	float h = float(tile.height); // * camera_info.zoom;

	vec2 a = vec2(screen_space_x - w * 0.5, screen_space_y);
	vec2 b = vec2(screen_space_x + w * 0.5, screen_space_y);
	vec2 c = vec2(screen_space_x - w * 0.5, screen_space_y + h);
	vec2 d = vec2(screen_space_x + w * 0.5, screen_space_y + h);

	uint v = tile_counter * 4;
	uint t = tile_counter * 2;

	gl_MeshVerticesEXT[v + 0].gl_Position = vec4(to_clip(a, screen_info.resolution), depth, 1);
	gl_MeshVerticesEXT[v + 1].gl_Position = vec4(to_clip(b, screen_info.resolution), depth, 1);
	gl_MeshVerticesEXT[v + 2].gl_Position = vec4(to_clip(c, screen_info.resolution), depth, 1);
	gl_MeshVerticesEXT[v + 3].gl_Position = vec4(to_clip(d, screen_info.resolution), depth, 1);

	output_color[v + 0] = vec3(depth * 50);
	output_color[v + 1] = vec3(depth * 50);
	output_color[v + 2] = vec3(depth * 50);
	output_color[v + 3] = vec3(depth * 50);

	output_uv[v + 0] = vec2(0, 1);
	output_uv[v + 1] = vec2(1, 1);
	output_uv[v + 2] = vec2(0, 0);
	output_uv[v + 3] = vec2(1, 0);

	output_atlas_id[v + 0] = tile.atlas_id;
	output_atlas_id[v + 1] = tile.atlas_id;
	output_atlas_id[v + 2] = tile.atlas_id;
	output_atlas_id[v + 3] = tile.atlas_id;

	gl_PrimitiveTriangleIndicesEXT[t + 0] = uvec3(v + 0, v + 2, v + 1);
	gl_PrimitiveTriangleIndicesEXT[t + 1] = uvec3(v + 2, v + 3, v + 1);
}

void main() {
	int block_base_x = int(gl_WorkGroupID.x) * 8;
	int block_base_y = (CHUNK_SIZE - 1) - int(gl_WorkGroupID.y);
	int block_base_z = int(gl_WorkGroupID.z) * 8;

	uint tile_counter = 0;

	for (int z = 7; z >= 0; z--) {
		for (int x = 7; x >= 0; x--) {

			ivec3 voxel_position = ivec3(block_base_x + x, block_base_y, block_base_z + z);

			uint voxel = get_voxel(voxel_position);

			if (VOXEL_IS_SOLID(voxel)) {

				uint tile_id = VOXEL_GET_TILE_ID(voxel);

				emit_tile(tile_counter, voxel_position, tile_id);

				tile_counter++;
			}
		}
	}

	SetMeshOutputsEXT(tile_counter * 4, tile_counter * 2);
}