#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_mesh_shader : require

#include "../math/constant.glsl"
#include "../vdb/common.glsl"

const float TILE_SIZE = 1.0;
const float TILE_HEIGHT = 0.5;

const vec4 q_fake_iso = vec4(
	0.239117607,
	0.369643837,
	-0.0990457684,
	0.892399073
);
const vec4 q_true_iso = vec4(
	0.279848129,
	0.364705235,
	-0.115916900,
	0.880476236
);

const vec3 vertex_fake[] = vec3[](
	vec3(-1.06066012, -0.866025448, 0.353553444),
	vec3(0.353553295, -0.866025448, -1.06066012),
	vec3(-0.353553295, 0.866025448, 1.06066012),
	vec3(1.06066012, 0.866025448, -0.353553444)
);
const vec3 vertex_true[] = vec3[](
	vec3(-1.11535501, -0.816496611, 0.298858583),
	vec3(0.298858404, -0.816496611, -1.11535501),
	vec3(-0.298858404, 0.816496611, 1.11535501),
	vec3(1.11535501, 0.816496611, -0.298858583)
);

layout (
	local_size_x = 8,
	local_size_y = 1,
	local_size_z = 8
) in;

layout (
	triangles,
	max_vertices = 256,
	max_primitives = 128
) out;

layout (location = 0) out vec3 output_color[];
layout (location = 1) out vec2 output_uv[];
layout (location = 2) out uint output_tile_index[];

layout (binding = 0) uniform camera_info_t {
	vec3 position;
	float reserved0;
	mat4 view;
	mat4 projection;
	mat4 view_projection;
	mat4 view_projection_inv;
	vec4 frustum_plane[6];
} camera_info;
layout (binding = 1) uniform usampler3D chunk_data[];

layout (push_constant) uniform push_constant_t {
	vec4 vertex_offset_0;
	vec4 vertex_offset_1;
	vec4 vertex_offset_2;
	vec4 vertex_offset_3;
	vec4 rotation;
	float tile_size;
	float tile_height;
	float depth_scale;
	float depth_eps;
} pc;

taskPayloadSharedEXT payload_t payload;

uint get_voxel(ivec3 voxel_position) {
	return uint(texelFetch(chunk_data[0], voxel_position, 0).r);
}

vec3 rotate_quat(vec4 q, vec3 v) {
	vec3 t = 2.0 * cross(q.xyz, v + cross(q.xyz, v) * q.w);
	return v + t;
}

vec4 quaternion_angle_axis(float a, vec3 b) {
	vec3 n = normalize(b);

	float a_half = a * 0.5;
	float s = sin(a_half);

	vec4 q = {
		n.x * s,
		n.y * s,
		n.z * s,
		cos(a_half),
	};

	return q;
}
vec4 quaternion_from_euler_angles(float p, float y, float r) {
	p *= DEG_TO_RAD;
	y *= DEG_TO_RAD;
	r *= DEG_TO_RAD;

	float sp = sin(p * 0.5);
	float sy = sin(y * 0.5);
	float sr = sin(r * 0.5);

	float cp = cos(p * 0.5);
	float cy = cos(y * 0.5);
	float cr = cos(r * 0.5);

	vec4 q = {
		sr * cp * cy - cr * sp * sy,
		cr * sp * cy + sr * cp * sy,
		cr * cp * sy - sr * sp * cy,
		cr * cp * cy + sr * sp * sy
	};

	return q;
}
vec4 quaternion_mul(vec4 a, vec4 b) {
	vec4 q = {
		(a.w * b.x) + (a.x * b.w) + (a.y * b.z) - (a.z * b.y),
		(a.w * b.y) - (a.x * b.z) + (a.y * b.w) + (a.z * b.x),
		(a.w * b.z) + (a.x * b.y) - (a.y * b.x) + (a.z * b.w),
		(a.w * b.w) - (a.x * b.x) - (a.y * b.y) - (a.z * b.z),
	};

	return q;
}

vec3 vector3_rotate(vec3 a, vec4 b) {
	float xx = b.x * b.x;
	float yy = b.y * b.y;
	float zz = b.z * b.z;

	float xy = b.x * b.y;
	float xz = b.x * b.z;
	float yz = b.y * b.z;

	float wx = b.w * b.x;
	float wy = b.w * b.y;
	float wz = b.w * b.z;

	vec3 v = {
		(1.0 - 2.0 * (yy + zz)) * a.x + 2.0 * (xy - wz) * a.y + 2.0 * (xz + wy) * a.z,
		2.0 * (xy + wz) * a.x + (1.0 - 2.0 * (xx + zz)) * a.y + 2.0 * (yz - wx) * a.z,
		2.0 * (xz - wy) * a.x + 2.0 * (yz + wx) * a.y + (1.0 - 2.0 * (xx + yy)) * a.z
	};

	return v;
}

void main() {
	int block_base_x = int(gl_WorkGroupID.x) * 8;
	int block_base_y = int(gl_WorkGroupID.y);
	int block_base_z = int(gl_WorkGroupID.z) * 8;

	uint tile_counter = 0;

	//vec4 qp = quaternion_angle_axis(pc.rotation.x * DEG_TO_RAD, vec3(1, 0, 0));
	//vec4 qy = quaternion_angle_axis(pc.rotation.y * DEG_TO_RAD, vec3(0, 1, 0));
	//vec4 qr = quaternion_angle_axis(pc.rotation.z * DEG_TO_RAD, vec3(0, 0, 1));

	//vec4 q = quaternion_mul(qy, quaternion_mul(qp, qr));

	for (int z = 0; z < 8; z++) {
		for (int x = 0; x < 8; x++) {
	
			ivec3 voxel_position = ivec3(block_base_x + x, block_base_y, block_base_z + z);
	
			uint voxel = get_voxel(voxel_position);
	
			if (VOXEL_IS_SOLID(voxel)) {

				vec4 a = vec4(voxel_position + vertex_fake[0], 1); // vector3_rotate(vec3(-1, -1, 0), q);
				vec4 b = vec4(voxel_position + vertex_fake[1], 1); // vector3_rotate(vec3(1, -1, 0), q);
				vec4 c = vec4(voxel_position + vertex_fake[2], 1); // vector3_rotate(vec3(-1, 1, 0), q);
				vec4 d = vec4(voxel_position + vertex_fake[3], 1); // vector3_rotate(vec3(1, 1, 0), q);

				uint v = tile_counter * 4;
				uint t = tile_counter * 2;

				gl_MeshVerticesEXT[v + 0].gl_Position = camera_info.view_projection * a;
				gl_MeshVerticesEXT[v + 1].gl_Position = camera_info.view_projection * b;
				gl_MeshVerticesEXT[v + 2].gl_Position = camera_info.view_projection * c;
				gl_MeshVerticesEXT[v + 3].gl_Position = camera_info.view_projection * d;

				output_color[v + 0] = vec3(1, 1, 1);
				output_color[v + 1] = vec3(1, 1, 1);
				output_color[v + 2] = vec3(1, 1, 1);
				output_color[v + 3] = vec3(1, 1, 1);

				output_uv[v + 0] = vec2(0.0, 1.0);
				output_uv[v + 1] = vec2(1.0, 1.0);
				output_uv[v + 2] = vec2(0.0, 0.0);
				output_uv[v + 3] = vec2(1.0, 0.0);

				output_tile_index[v + 0] = 0;
				output_tile_index[v + 1] = 0;
				output_tile_index[v + 2] = 0;
				output_tile_index[v + 3] = 0;

				gl_PrimitiveTriangleIndicesEXT[t + 0] = uvec3(v + 0, v + 2, v + 1);
				gl_PrimitiveTriangleIndicesEXT[t + 1] = uvec3(v + 2, v + 3, v + 1);
	
				tile_counter++;
			}
		}
	}

	SetMeshOutputsEXT(tile_counter * 4, tile_counter * 2);
}