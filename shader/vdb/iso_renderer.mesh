#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_mesh_shader : require

#include "../vdb/common.glsl"

const float GLOBAL_TILE_SIZE = 0.5;
const float GLOBAL_TILE_HEIGHT = 0.5;

const float DEPTH_SCALE = 0.001;
const float DEPTH_EPS = 0.00001;

layout (
	local_size_x = 4,
	local_size_y = 1,
	local_size_z = 4
) in;

layout (
	triangles,
	max_vertices = 192,
	max_primitives = 96
) out;

layout (location = 0) out vec3 output_color[];
layout (location = 1) out vec2 output_uv[];
layout (location = 2) out uint output_atlas_id[];

layout (binding = 0) uniform camera_info_t {
	vec3 position;
	float reserved0;
	mat4 view;
	mat4 projection;
	mat4 view_projection;
	mat4 view_projection_inv;
	vec4 frustum_plane[6];
} camera_info;
layout (binding = 1) readonly buffer tile_lut_buffer_t {
	tile_lut_t tile_lut[];
} tile_lut_buffer;
layout (binding = 2) uniform usampler3D chunk_data[];

layout (push_constant) uniform push_constant_t {
	vec4 vertex_offset_0;
	vec4 vertex_offset_1;
	vec4 vertex_offset_2;
	vec4 vertex_offset_3;
	vec4 rotation;
	float tile_size;
	float tile_height;
	float inner_scale;
	float outer_scale;
} pc;

taskPayloadSharedEXT payload_t payload;

uint get_voxel(ivec3 voxel_position) {
	return uint(texelFetch(chunk_data[0], voxel_position, 0).r);
}

float iso_depth(vec3 p) {
	return (p.x + p.z + p.y) * DEPTH_SCALE;
}

vec3 iso_project(vec3 p, float depth_bias) {
	float iso_x = p.x - p.z;
	float iso_y = (p.x + p.z) * 0.5 - p.y;
	float iso_z = iso_depth(p) + depth_bias;

	return vec3(iso_x, iso_y, iso_z);
}

vec2 uv_top(vec3 p, vec3 base, float sx, float sz) {
	vec2 local = (p.xz - base.xz);

	return vec2(local.x / sx, local.y / sz);
}

vec2 uv_side_x(vec3 p, vec3 base, float sx, float sy) {
	vec2 local = vec2(p.x - base.x, p.y - base.y);

	return vec2(local.x / sx, local.y / sy);
}

vec2 uv_side_z(vec3 p, vec3 base, float sz, float sy) {
	vec2 local = vec2(p.z - base.z, p.y - base.y);

	return vec2(local.x / sz, local.y / sy);
}

void emit_quad(uint v, uint t, vec3 a, vec3 b, vec3 c, vec3 d, vec2 uva, vec2 uvb, vec2 uvc, vec2 uvd, float depth_bias, vec3 color, uint atlas_id) {
	gl_MeshVerticesEXT[v + 0].gl_Position = camera_info.view_projection * vec4(iso_project(a, depth_bias), 1);
	gl_MeshVerticesEXT[v + 1].gl_Position = camera_info.view_projection * vec4(iso_project(b, depth_bias), 1);
	gl_MeshVerticesEXT[v + 2].gl_Position = camera_info.view_projection * vec4(iso_project(c, depth_bias), 1);
	gl_MeshVerticesEXT[v + 3].gl_Position = camera_info.view_projection * vec4(iso_project(d, depth_bias), 1);

	output_color[v + 0] = color;
	output_color[v + 1] = color;
	output_color[v + 2] = color;
	output_color[v + 3] = color;

	output_uv[v + 0] = uva;
	output_uv[v + 1] = uvb;
	output_uv[v + 2] = uvc;
	output_uv[v + 3] = uvd;

	output_atlas_id[v + 0] = atlas_id;
	output_atlas_id[v + 1] = atlas_id;
	output_atlas_id[v + 2] = atlas_id;
	output_atlas_id[v + 3] = atlas_id;

	gl_PrimitiveTriangleIndicesEXT[t + 0] = uvec3(v + 0, v + 1, v + 2);
	gl_PrimitiveTriangleIndicesEXT[t + 1] = uvec3(v + 2, v + 3, v + 0);
}

void emit_tile(uint tile_counter, vec3 voxel_position, uint tile_id) {
	tile_lut_t tile_lut = tile_lut_buffer.tile_lut[tile_id];

	float sx = tile_lut.size_x * GLOBAL_TILE_SIZE;
	float sy = tile_lut.size_y * GLOBAL_TILE_HEIGHT;
	float sz = tile_lut.size_z * GLOBAL_TILE_SIZE;

	vec3 base = vec3(
		voxel_position.x * sx,
		voxel_position.y * sy,
		voxel_position.z * sz
	);

	float depth_top  = iso_depth(voxel_position) - DEPTH_EPS;
	float depth_side = iso_depth(voxel_position) + DEPTH_EPS;

	uint v = tile_counter * 12;
	uint t = tile_counter * 6;

	vec3 ta = base + vec3(0, 0, sz);
	vec3 tb = base + vec3(sx, 0, sz);
	vec3 tc = base + vec3(sx, 0, 0);
	vec3 td = base + vec3(0, 0, 0);

	vec3 xa = base + vec3(0, 0, 0);
	vec3 xb = base + vec3(sx, 0, 0);
	vec3 xc = base + vec3(sx, sy, 0);
	vec3 xd = base + vec3(0, sy, 0);

	vec3 za = base + vec3(0, 0, sz);
	vec3 zb = base + vec3(0, 0, 0);
	vec3 zc = base + vec3(0, sy, 0);
	vec3 zd = base + vec3(0, sy, sz);

	emit_quad(
		v + 0, t + 0,
		ta, tb, tc, td,
		uv_top(ta, base, sx, sz),
		uv_top(tb, base, sx, sz),
		uv_top(tc, base, sx, sz),
		uv_top(td, base, sx, sz),
		depth_top,
		vec3(0.8, 0.9, 1.0),
		0
	);

	emit_quad(
		v + 4, t + 2,
		xa, xb, xc, xd,
		uv_side_x(xa, base, sx, sy),
		uv_side_x(xb, base, sx, sy),
		uv_side_x(xc, base, sx, sy),
		uv_side_x(xd, base, sx, sy),
		depth_side,
		vec3(0.55, 0.7, 0.9),
		1
	);

	emit_quad(
		v + 8, t + 4,
		za, zb, zc, zd,
		uv_side_z(za, base, sz, sy),
		uv_side_z(zb, base, sz, sy),
		uv_side_z(zc, base, sz, sy),
		uv_side_z(zd, base, sz, sy),
		depth_side,
		vec3(0.45, 0.6, 0.85),
		2
	);

	//emit_quad(
	//	v + 0, t + 0,
	//	world_base + vec3(0, 0, sz),
	//	world_base + vec3(sx, 0, sz),
	//	world_base + vec3(sx, 0, 0),
	//	world_base + vec3(0, 0, 0),
	//	depth_top,
	//	vec3(0.8, 0.9, 1.0),
	//	tile_lut.atlas_id
	//);

	//emit_quad(
	//	v + 4, t + 2,
	//	world_base + vec3(0, 0, 0),
	//	world_base + vec3(sx, 0, 0),
	//	world_base + vec3(sx, sy, 0),
	//	world_base + vec3(0, sy, 0),
	//	depth_side,
	//	vec3(0.55, 0.7, 0.9),
	//	tile_lut.atlas_id
	//);

	//emit_quad(
	//	v + 8, t + 4,
	//	world_base + vec3(0, 0, sz),
	//	world_base + vec3(0, 0, 0),
	//	world_base + vec3(0, sy, 0),
	//	world_base + vec3(0, sy, sz),
	//	depth_side,
	//	vec3(0.45, 0.6, 0.85),
	//	tile_lut.atlas_id
	//);
}

void main() {
	int block_base_x = int(gl_WorkGroupID.x) * 4;
	int block_base_y = (CHUNK_SIZE - 1) - int(gl_WorkGroupID.y);
	int block_base_z = int(gl_WorkGroupID.z) * 4;

	uint tile_counter = 0;

	for (int z = 3; z >= 0; z--) {
		for (int x = 3; x >= 0; x--) {

			ivec3 voxel_position = ivec3(block_base_x + x, block_base_y, block_base_z + z);

			uint voxel = get_voxel(voxel_position);

			if (VOXEL_IS_SOLID(voxel)) {

				uint tile_id = VOXEL_GET_TILE_ID(voxel);

				emit_tile(tile_counter, voxel_position, tile_id);

				tile_counter++;
			}
		}
	}

	SetMeshOutputsEXT(tile_counter * 12, tile_counter * 6);
}